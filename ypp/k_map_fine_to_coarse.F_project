!
!        Copyright (C) 2000-2014 the YAMBO team
!              http://www.yambo-code.org
!
! Authors (see AUTHORS file for details): AM DS
! 
! This file is distributed under the terms of the GNU 
! General Public License. You can redistribute it and/or 
! modify it under the terms of the GNU General Public 
! License as published by the Free Software Foundation; 
! either version 2, or (at your option) any later version.
!
! This program is distributed in the hope that it will 
! be useful, but WITHOUT ANY WARRANTY; without even the 
! implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE.  See the GNU General Public License 
! for more details.
!
! You should have received a copy of the GNU General Public 
! License along with this program; if not, write to the Free 
! Software Foundation, Inc., 59 Temple Place - Suite 330,Boston, 
! MA 02111-1307, USA or visit http://www.gnu.org/copyleft/gpl.txt.
!
subroutine k_map_fine_to_coarse(Xk,Xen)
 !
 use pars,                ONLY:SP,DP,lchlen,schlen
 use units,               ONLY:HA2EV
 use zeros,               ONLY:k_iku_zero,k_rlu_zero,define_zeros
 use stderr,              ONLY:set_real_printed_length,intc
 use R_lattice,           ONLY:bz_samp,nkibz,k_the_nearest,bz_samp_reset,rl_sop
 use parser_m,            ONLY:parser
 use D_lattice,           ONLY:alat,nsym,input_GS_Tel,a,dl_sop,i_time_rev,sop_tab
 use com,                 ONLY:msg,of_open_close,error,warning
 use vec_operate,         ONLY:v_norm,c2a,k2bz,v_is_zero
 use YPP,                 ONLY:RIM_DB1_paths,K_transform,n_RIM_DBs
 use electrons,           ONLY:levels,default_nel,n_bands,RIM_nbands,                            &
&                               BZ_RIM_nkpt, BZ_RIM_table, BZ_RIM_tot_nkpts, BZ_RIM_max_filling, &
&                              IBZ_RIM_nkpt,IBZ_RIM_table,IBZ_RIM_tot_nkpts,IBZ_RIM_max_filling, &
&                              n_sp_pol,E_reset,BZ_RIM_ipol_weight
 use LIVE_t,              ONLY:live_timing
 use IO_m,                ONLY:io_control,LOG,OP_WR_CL
 !
 implicit none
 !
 type(bz_samp) :: Xk
 type(levels)  :: Xen
 !
 ! Work Space
 !
 real(SP)     :: a_save(3,3),alat_save(3),gap(2),tmp_zero(3),dl_sop_save(3,3,48)
 integer      :: i1,ik_near,is_near,RIM_nk,ik_bz,ik_ibz,is,ik_RIM,ik_ref(2)
 logical      :: No_Weight,l_skip_check
 !
 ! Allocs
 ! 
 integer,  allocatable :: BZ_SYM_table(:,:),IBZ_SYM_table(:,:)
 !
 ! BZ DB1 I/O
 !
 type(levels)      :: RIM_E_in(n_RIM_DBs),RIM_E
 type(bz_samp)     :: RIM_k_in(n_RIM_DBs),RIM_k
 integer           :: ID,IBZ_RIM_tot_nkpts
 integer           :: i_err(n_RIM_DBs),nsym_save,nsym_RIM_DB
 integer           :: i_time_rev_save,i_time_rev_DB
 integer           :: i_db,i_db_merge
 integer, external :: ioDB1_selective_scan,io_RIM_E_and_k
 !
 ! Part 1 : Read DBs
 !======================
 !
 if (n_RIM_DBs==0) then
   call msg("s",'RIM: no database secified. Nothing to do.')
   return
 endif
 !
 ! Saves 2 check
 !
 a_save=a
 alat_save=alat
 nsym_save=nsym
 dl_sop_save(:,:,:nsym)=dl_sop
 i_time_rev_save=i_time_rev
 !
 ! DB1 reloading
 !
 i_err=0
 do i_db=1,n_RIM_DBs
   i_err(i_db)=ioDB1_selective_scan(RIM_E_in(i_db),RIM_k_in(i_db),trim(RIM_DB1_paths(i_db,1)),'all')
   if (i_err(i_db)/=0) call msg("s",'RIM database in '//trim(RIM_DB1_paths(i_db,1))//' NOT FOUND')
   if (i_err(i_db)==0) call msg("s",'RIM database in'//trim(RIM_DB1_paths(i_db,1))//' FOUND')
   !
   ! DB1 checks
   !
   if (i_err(i_db)==0.and.any(a/=a_save))  then
     call msg("s",':: RIM DB1 DL structure does not fit')
     i_err(i_db)=-1
   endif
   if (i_err(i_db)==0.and.any(alat/=alat_save))  then
     call msg("s",':: RIM DB1 alat does not fit.')
     i_err(i_db)=-1
   endif
   !
 enddo
 !
 if (any((/i_err(:n_RIM_DBs)/=0/))) call error(" One or more RIM databases have not been found")
 !
 ! Symmetry restoring
 !
 if (allocated(dl_sop)) then
   deallocate(dl_sop)
   nsym_RIM_DB=nsym
   nsym       =nsym_save
   i_time_rev_DB=i_time_rev
   i_time_rev   =i_time_rev_save
   allocate(dl_sop(3,3,nsym))
   dl_sop=dl_sop_save(:,:,:nsym)
 endif
 !
 call parser('NoWeights',No_Weight)
 call parser('SkipCheck',l_skip_check)
 !
 call section('*','BZ RIM DB(s)')
 !
 call msg('s',':: Electrons             :',default_nel)
 call msg('s',':: Temperature       [ev]:',input_GS_Tel)
 call msg('s',':: Lattice factors [a.u.]:',alat)
 do i_db=1,n_RIM_DBs
   if (i_db==1) call msg('s',':: K points        [DB #'//trim(intc(i_db))//']:',RIM_E_in(i_db)%nk)
   if (i_db> 1) call msg('s','::                 [DB #'//trim(intc(i_db))//']:',RIM_E_in(i_db)%nk)
 enddo
 !
 ! Mergering of ALL RIM_E_in(:) => RIM_E
 !
 call bz_samp_reset(RIM_k)
 call E_reset(RIM_E)
 RIM_E%nk=sum(RIM_E_in(:n_RIM_DBs)%nk)
 RIM_E%nb=RIM_E_in(1)%nb
 RIM_k%nibz=sum(RIM_E_in(:n_RIM_DBs)%nk)
 allocate(RIM_E%E(RIM_E%nb,RIM_E%nk,n_sp_pol))
 allocate(RIM_k%pt(RIM_E%nk,3))
 do i_db=1,n_RIM_DBs
   if (i_db==1) ik_ref(1)=0
   if (i_db> 1) ik_ref(1)=sum(RIM_E_in(1:i_db-1)%nk)
   do ik_RIM=1,RIM_E_in(i_db)%nk
     RIM_E%E(:,ik_RIM+ik_ref(1),:)= RIM_E_in(i_db)%E(:,ik_RIM,:)
     RIM_k%pt(ik_RIM+ik_ref(1),:)= RIM_k_in(i_db)%pt(ik_RIM,:)
   enddo
 enddo
 !
 ! Now that I have the finer grid of Kpts I redefine the zeros for the kpts
 !
 call define_zeros(vector_=RIM_k%pt, zero_=tmp_zero)
 k_iku_zero=min(k_iku_zero,tmp_zero)
 call define_zeros(vector_=RIM_k%pt, zero_=tmp_zero,RLU=.TRUE.)
 k_rlu_zero=min(k_rlu_zero,tmp_zero)
 !
 gap(1)=minval(RIM_E%E(Xen%nbf+1,:,1))-maxval(RIM_E%E(Xen%nbf,:,1)) 
 gap(2)=10000.
 do ik=1,nkibz
   if (RIM_E%E(Xen%nbf+1,ik,1)-RIM_E%E(Xen%nbf,ik,1)<gap(2)) then
     gap(2)=RIM_E%E(Xen%nbf+1,ik,1)-RIM_E%E(Xen%nbf,ik,1)
   endif
 enddo
 !
 call msg('s',':: Bands                 :',n_bands)
 call msg('s',':: Symmetries            :',nsym_RIM_DB)
 if(i_time_rev_DB==1)&
&   call msg('s',':: Time reversal included ')
 if(i_time_rev_DB==0)&
&   call msg('s',':: Time reversal not included')
 if (Xen%nbf==Xen%nbm) then
   call msg('s',':: Gap indirect      [ev]:',gap(1)*HA2EV)
   call msg('s','::     direct        [ev]:',gap(2)*HA2EV)
 endif
 !
 ! See if there is correspondance between the random and the built-in
 ! k-points
 !
 call section('+','Internal consistency check ...')
 ik_ref=0
 ik_loop: do ik=1,Xen%nk
   do ik_RIM=1,RIM_E%nk
     if (v_is_zero(RIM_k%pt(ik_RIM,:)-Xk%pt(ik,:))) then
       ik_ref=(/ik,ik_RIM/)
       exit  ik_loop
     endif
   enddo
 enddo ik_loop
 !
 RIM_nbands=RIM_E%nb
 !
 RIM_nk=RIM_k%nibz
 !
 IBZ_RIM_tot_nkpts=RIM_k%nibz+Xk%nibz
 !
 if (ik_ref(1)> 0) then
   call msg('l','passed') 
   RIM_E%E(:,:,:)=RIM_E%E(:,:,:)+Xen%E(Xen%nbm,ik_ref(1),1)-RIM_E%E(Xen%nbm,ik_ref(2),1)
   call msg('s','Energy levels aligned')
   ! The reference must not be counted twice
   IBZ_RIM_tot_nkpts=IBZ_RIM_tot_nkpts-1
 else 
   call msg('l','failed') 
   if (     l_skip_check) call warning("Internal check failed. A X grid k-point was not found among the RIM list")
   if (.not.l_skip_check) call error("Internal check failed. A X grid k-point was not found among the RIM list")
 endif
 !
 ! Part 2 : Maps IBZ --> IBZ
 !=============================
 !
 ! First expand and then reduce kpts
 !
 call section('+','BZ RIM K-points reduction ...')
 !
 call k_ibz2bz(RIM_k,'i',.true.)
 call k_reduce(RIM_k)
 !
 call msg('l','from '//trim(intc(RIM_nk))//' to '//trim(intc(RIM_k%nibz))//') points in the IBZ')
 !
 IBZ_RIM_tot_nkpts=IBZ_RIM_tot_nkpts+RIM_k%nibz-RIM_nk
 !
 RIM_nk=RIM_k%nibz
 !
 deallocate(RIM_E%E)
 !
 allocate(RIM_E%E(RIM_E(RIM_nbands,RIM_nk,n_sp_pol))
 !
 allocate(IBZ_RIM_nkpt(Xk%nibz))
 IBZ_RIM_nkpt=1
 !
 call live_timing('IBZ RIM Tables',RIM_nk*2,SERIAL=.true.)
 !
 do i1=1,2
   if (i1==2) then
     !
     allocate(IBZ_RIM_table(Xk%nibz,maxval(IBZ_RIM_nkpt)))
     IBZ_RIM_table=0
     do ik=1,Xk%nibz
       IBZ_RIM_table(ik,1)=ik
     enddo
     !
     allocate(IBZ_SYM_table(Xk%nibz,IBZ_RIM_tot_nkpts))
     IBZ_SYM_table=0
     IBZ_SYM_table(1:Xk%nibz,1)=1
     !
   endif
   !
   IBZ_RIM_nkpt=1
   !
   do ik_RIM=1,RIM_nk
     !
     if (ik_RIM==ik_ref(2)) then
       call live_timing(steps=1)
       cycle
     endif
     !
     ik_near =Xk%s_table( k_the_nearest(RIM_k(i_db_merge)%pt(ik_RIM,:),Xk%pt(:,:),Xk%nibz,ROTATE_k_ref=.TRUE.,k_symm=is_near) , 1)
     IBZ_RIM_nkpt(ik_near)=IBZ_RIM_nkpt(ik_near)+1
     if (allocated(BZ_SYM_table)) IBZ_SYM_table(ik_near,IBZ_RIM_nkpt(ik_near))=is_near
     if (allocated(BZ_RIM_table_tmp)) IBZ_RIM_table(ik_near,IBZ_RIM_nkpt(ik_near))=ik_RIM+1
     !
     call live_timing(steps=1)
     !
   enddo
 enddo
 !
 call live_timing()
 !
 call msg('s',':: Blocks filling range  :',(/minval(IBZ_RIM_nkpt),maxval(IBZ_RIM_nkpt)/))
 !
 IBZ_RIM_max_filling=maxval(IBZ_RIM_nkpt)
 !
 call live_timing('IBZ RIM re-ordering and distribution',Xk%nbz,SERIAL=.true.)
 !
 allocate(Xen%E_RIM(RIM_nbands,IBZ_RIM_tot_nkpts,n_sp_pol))
 i1=0
 !
 do ik=1,Xk%nibz
   do ik_RIM=1,IBZ_RIM_nkpt(ik)
     i1=i1+1
     if (ik_RIM==1) then
       Xen%E_RIM(:,i1,:)=Xen%E(:RIM_nbands,IBZ_RIM_table(ik,1),:)
       Xk%pt_RIM(i1,:)  =Xk%pt(ik,:)
     else
       Xen%E_RIM(:,i1,:)=RIM_E%E(:,IBZ_RIM_table(ik,ik_RIM)-1,:)
       Xk%pt_RIM(i1,:)  =matmul(rl_sop(:,:, IBZ_SYM_table(ik,ik_RIM) ),RIM_k%pt(IBZ_RIM_table(ik,ik_RIM)-1,:))
     endif
     BZ_RIM_table(ik_bz,ik_RIM)=ik_RIM+sum(BZ_RIM_nkpt(:ik_bz-1))
   enddo
   call live_timing(steps=1)
 enddo
 !
 
 !
 call live_timing()
 !
 !
 ! Part 3 : Maps BZ --> BZ
 !=============================
 !
 !
 !
 ! Xk (IBZ->BZ)
 !
 call k_sym2sym(Xk,'k')
 call k_ibz2bz(Xk,'i',.true.)
 !
 call section('+','BZ RIM K-points expansion ...')
 !
 ! RIM_k (IBZ->BZ)
 !
 call k_sym2sym(RIM_k,'k')
 call k_ibz2bz(RIM_k,'i',.true.)
 !
 call msg('l','found '//trim(intc(RIM_k%nbz))//' ('//trim(intc(RIM_k%nibz))//') points in the BZ (IBZ)')
 !
 BZ_RIM_tot_nkpts=RIM_k%nbz+Xk%nbz-1
 !


 !
 allocate(BZ_RIM_nkpt_zero(Xk%nbz))
 BZ_RIM_nkpt_zero=BZ_RIM_nkpt
 !
 allocate(Xk%ptbz_RIM(BZ_RIM_tot_nkpts,3))
 !
 !
 ! Now expand the spheres around points in the IBZ with hig symmetry
 call live_timing('RIM expand tables around k-points with high symmetries',Xk%nbz,SERIAL=.true.)
 !
 !
 do ik_ibz=1,Xk%nibz
   ik_bz_ref=Xk%s_table(ik_ibz,1)
   do is=2,nsym
     ik_rot=Xk%s_table(ik_ibz,is)
     !
     if(ik_rot=/ik_bz_ref) cycle
     !
     BZ_RIM_nkpt(ik_rot)=BZ_RIM_nkpt(ik_rot)+BZ_RIM_nkpt_zero(ik_rot)
     !
     do ik_RIM=1,BZ_RIM_nkpt_zero(ik_bz)
       ik_RIM_shift=ik_RIM+BZ_RIM_nkpt(ik_rot)-BZ_RIM_nkpt_zero(ik_rot)
       !
       BZ_RIM_table_tmp(ik_rot,ik_RIM_shift)=BZ_RIM_table_tmp(ik_rot,ik_RIM)
       BZ_SYM_table(ik_rot,ik_RIM_shift)=sop_table(is,BZ_SYM_table(ik_rot,ik_RIM))
       !
     enddo
     !
   enddo
   !
 enddo
 !
 call live_timing('BZ RIM rotate tables from IBZ to BZ',Xk%nbz,SERIAL=.true.)
 !
 i1=0
 do ik_bz=1,Xk%nbz
   ik_ibz=Xk%sstar(ik_bz,1)
   is    =Xk%sstar(ik_bz,2)
   if(is>1) BZ_RIM_nkpt(ik_bz)=BZ_RIM_nkpt(Xk%s_table(ik_ibz,1))
   do ik_RIM=1,BZ_RIM_nkpt(ik_bz)
     i1=i1+1
     if (ik_RIM==1) then
       Xen%E_RIM(:,i1,:)=Xen%E(:BZ_RIM_nbands,BZ_RIM_table(ik_bz,1),:)
       Xk%ptbz_RIM(i1,:)=Xk%ptbz(ik_bz,:)
     else
       Xen%E_RIM(:,i1,:)=RIM_E(i_db_merge)%E(:,BZ_RIM_table(ik_bz,ik_RIM)-1,:)
       Xk%ptbz_RIM(i1,:)=matmul( rl_sop(:,:, sop_tab( is,BZ_SYM_table(ik_bz,ik_RIM)) ), &
       &                         RIM_k(i_db_merge)%pt(BZ_RIM_table(ik_bz,ik_RIM)-1,:)   )
     endif
     BZ_RIM_table(ik_bz,ik_RIM)=ik_RIM+sum(BZ_RIM_nkpt(:ik_bz-1))
   enddo
   call live_timing(steps=1)
 enddo
 !
 call live_timing()

 !
 ! RIM double grid interpolation weights, not used here, but must be defined.
 !
 allocate(BZ_RIM_ipol_weight(BZ_RIM_max_filling))
 BZ_RIM_ipol_weight = 1.0_SP
 !
 !
 ! Final I/O
 !
 call io_control(ACTION=OP_WR_CL,SEC=(/1/),COM=LOG,ID=ID)
 i_err=io_RIM_E_and_k(Xen,Xk,ID)
 !
 ! CLEAN
 !
 deallocate(BZ_RIM_nkpt,BZ_RIM_table,BZ_RIM_table_tmp,Xen%E_RIM,BZ_RIM_ipol_weight)
 if(allocated(BZ_SYM_table)) deallocate(BZ_SYM_table)
 if(associated(Xk%ptbz_RIM)) deallocate(Xk%ptbz_RIM)
 !if(associated(Xk%pt_RIM))   deallocate(Xk%pt_RIM)
 call k_ibz2bz(Xk,'d',.false.) 
 call k_ibz2bz(RIM_k(i_db_merge),'d',.false.) 
 !
end subroutine
