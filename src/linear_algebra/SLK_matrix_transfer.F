!
!        Copyright (C) 2000-2016 the YAMBO team
!              http://www.yambo-code.org
!
! Authors (see AUTHORS file for details): AM
!
! This file is distributed under the terms of the GNU 
! General Public License. You can redistribute it and/or 
! modify it under the terms of the GNU General Public 
! License as published by the Free Software Foundation; 
! either version 2, or (at your option) any later version.
!
! This program is distributed in the hope that it will 
! be useful, but WITHOUT ANY WARRANTY; without even the 
! implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE.  See the GNU General Public License 
! for more details.
!
! You should have received a copy of the GNU General Public 
! License along with this program; if not, write to the Free 
! Software Foundation, Inc., 59 Temple Place - Suite 330,Boston, 
! MA 02111-1307, USA or visit http://www.gnu.org/copyleft/gpl.txt.
!
SUBROUTINE SLK_matrix_transfer( mode, M_slk, M_bse, M )
 !
 ! mode can be "fill_the_SLK" "transfer_from_the_SLK"
 !
 use pars,           ONLY:SP,cZERO
 use SLK_m,          ONLY:SLK_matrix,SLK_POOL,n_pools
 use BS,             ONLY:BS_block,n_BS_blks
 use parallel_m,     ONLY:PP_redux_wait,MPI_COMPLEX,MPI_STATUS_SIZE,ncpu,myid,mpi_comm_world
 use linear_algebra, ONLY:SLK_matrix_transfer_side_crop
 !
 implicit none
 !
 character(*)     :: mode
 type(SLK_matrix) :: M_slk
 type(BS_block), optional :: M_bse(:)
 complex(SP),    optional :: M(:,:)
 !
 ! Work Space
 !
 integer :: i_B,i_c1,i_c2,GLOBAL_n_BS_blks(ncpu),i_err,BUFF_size,&
&           SLK_coordinates(SLK_POOL%n_CPU,4),K_coo(4),MAX_n_BS_blks,i_r,i_c,&
&           i_r_,i_c_,SLK_cpu_id_in_the_world(SLK_POOL%n_CPU),i_pool
 integer, dimension(MPI_STATUS_SIZE) :: MPI_status
 integer, allocatable                :: BSE_coordinates(:,:,:),BSE_iTs(:,:,:)
 !
 if (mode=="fill_the_SLK") then
   !
   if (present(M)) then
     !
     M_slk%blc(:M_slk%nrows_used,:M_slk%ncols_used)=M(M_slk%rows(1):M_slk%rows(2),M_slk%cols(1):M_slk%cols(2))
     !
     return
     !
   endif
   !
   if (present(M_bse)) then
     !
     ! SLK
     !
     SLK_coordinates                      =0
     SLK_coordinates(SLK_POOL%CPU_id+1,:) =(/M_slk%rows(1),M_slk%rows(2),M_slk%cols(1),M_slk%cols(2)/)
     call PP_redux_wait(SLK_coordinates ,COMM=SLK_POOL%INTRA_comm)
     !
     ! BSE
     !
     GLOBAL_n_BS_blks         =0
     GLOBAL_n_BS_blks(myid+1) =n_BS_blks
     call PP_redux_wait(GLOBAL_n_BS_blks)
     MAX_n_BS_blks=maxval(GLOBAL_n_BS_blks)
     allocate(BSE_coordinates(ncpu,MAX_n_BS_blks,4))
     allocate(BSE_iTs(ncpu,MAX_n_BS_blks,2))
     BSE_coordinates =0
     BSE_iTs         =0
     !
     do i_B=1,n_BS_blks
       !
       BSE_iTs        (myid+1,i_B,:)=(/M_bse(i_B)%iT_k,M_bse(i_B)%iT_p/)
       !
       BSE_coordinates(myid+1,i_B,:)  =(/M_bse(i_B)%coordinate(1),M_bse(i_B)%coordinate(1)+M_bse(i_B)%size(1)-1,&
&                                        M_bse(i_B)%coordinate(2),M_bse(i_B)%coordinate(2)+M_bse(i_B)%size(2)-1/)
       !
     enddo
     !  
     call PP_redux_wait(BSE_iTs         )
     call PP_redux_wait(BSE_coordinates )
     !
     do i_pool=1,n_pools
       !
       SLK_cpu_id_in_the_world  =0
       if (SLK_POOL%ID==i_pool-1) SLK_cpu_id_in_the_world(SLK_POOL%CPU_id+1)=myid+1
       !
       call PP_redux_wait(SLK_cpu_id_in_the_world)
       !
       ! Here I define the list of "local buffers" to exchange. They are the minimal overlaps of the
       ! SLK and BSE sub-matrices.
       !
       do i_c1=1,SLK_POOL%n_CPU
         !
         ! i_c1 is the BLACS cpu
         !
         do i_c2=1,ncpu
           !
           ! i_c1 is the BS cpu
           !
           do i_B=1,GLOBAL_n_BS_blks(i_c2)
             !
             ! Here I crop the part of the BS block that fits into the BLACS structure. I crop the two sides of the
             ! K block
             !
             ! Resonant block 
             !
             call SLK_matrix_transfer_side_crop(SLK_coordinates(i_c1,1:2), BSE_coordinates(i_c2,i_B,1:2), K_coo(1:2) )
             call SLK_matrix_transfer_side_crop(SLK_coordinates(i_c1,3:4), BSE_coordinates(i_c2,i_B,3:4), K_coo(3:4) )
             if (.not.any(K_coo==0)) call elemental_transfer('N')
             call PP_redux_wait( )
             !
             !
             if (BSE_iTs(i_c2,i_B,1)/=BSE_iTs(i_c2,i_B,2)) then
               !
               ! Symmetric block of the resonant
               !
               call SLK_matrix_transfer_side_crop(SLK_coordinates(i_c1,1:2), BSE_coordinates(i_c2,i_B,3:4), K_coo(1:2) )
               call SLK_matrix_transfer_side_crop(SLK_coordinates(i_c1,3:4), BSE_coordinates(i_c2,i_B,1:2), K_coo(3:4) )
               if (.not.any(K_coo==0)) call elemental_transfer('C')
               !
             endif
             !
           enddo
           !
         enddo
         !
       enddo
       !
     enddo
     !
     deallocate(BSE_coordinates,BSE_iTs)
     return
     !
   endif
   !
 endif
 !
 if (mode=="transfer_from_the_SLK") then
   !
   if (present(M)) then
     !
     M=cZERO
     !
     M(M_slk%rows(1):M_slk%rows(2),M_slk%cols(1):M_slk%cols(2))=M_slk%blc(:M_slk%nrows_used,:M_slk%ncols_used)
     !
     call PP_redux_wait(M,COMM=SLK_POOL%INTRA_comm)
     !
     return
     !
   endif
   !
 endif
 !
 contains
   !
   subroutine elemental_transfer(mode)
     !
     character(1) :: mode
     complex(SP)  :: M_tmp(K_coo(1):K_coo(2),K_coo(3):K_coo(4))
     !
     integer      :: SLK_blk_coo(4)
     integer      :: i_r_in_BLK,i_c_in_BLK
     !
     if (myid/=i_c2-1.and.myid/=SLK_cpu_id_in_the_world(i_c1)-1) return
     !
     SLK_blk_coo(1:2) = K_coo(1:2)-M_slk%rows(1)+1
     SLK_blk_coo(3:4) = K_coo(3:4)-M_slk%cols(1)+1
     !
     BUFF_size    = (SLK_blk_coo(2)-SLK_blk_coo(1)+1)*(SLK_blk_coo(4)-SLK_blk_coo(3)+1)
     !
     if (myid==i_c2-1) then
       !
       do i_r=K_coo(1),K_coo(2)
         do i_c=K_coo(3),K_coo(4)
           !
           i_r_in_BLK=i_r-BSE_coordinates(i_c2,i_B,1)+1
           i_c_in_BLK=i_c-BSE_coordinates(i_c2,i_B,3)+1
           !
           if (mode=="C") then
             i_r_in_BLK=i_c-BSE_coordinates(i_c2,i_B,1)+1
             i_c_in_BLK=i_r-BSE_coordinates(i_c2,i_B,3)+1
           endif
           !
           if (mode=="N") then
             M_tmp(i_r,i_c)=M_bse(i_B)%mat(i_r_in_BLK,i_c_in_BLK)
           else if (mode=="C") then
             M_tmp(i_r,i_c)=conjg(M_bse(i_B)%mat(i_r_in_BLK,i_c_in_BLK))
           endif
           !
           if (i_r==i_c) M_tmp(i_r,i_c)=real( M_tmp(i_r,i_c) )
           !
         enddo
       enddo
       !
       if (i_c2==SLK_cpu_id_in_the_world(i_c1)) then
         M_slk%blc(SLK_blk_coo(1):SLK_blk_coo(2),SLK_blk_coo(3):SLK_blk_coo(4))=M_tmp
       else
         call MPI_SEND(M_tmp,BUFF_size, MPI_COMPLEX, SLK_cpu_id_in_the_world(i_c1)-1, 1, mpi_comm_world,i_err)
       endif
       !
       return
       !
     endif
     !
     if (myid==SLK_cpu_id_in_the_world(i_c1)-1) then
       !
       call MPI_RECV(M_slk%blc(SLK_blk_coo(1):SLK_blk_coo(2),SLK_blk_coo(3):SLK_blk_coo(4)),BUFF_size,MPI_COMPLEX,&
&                    i_c2-1, 1, mpi_comm_world,MPI_status,i_err)
       !
     endif
     !
   end subroutine
   ! 
end SUBROUTINE
